# 设计方案
## 中断异常
### CP0
**功能**  
判断是否需要进行中断异常，向其他模块发送中断信号，并记录陷入内核时的地址  
**设计**  
```
Reg: SR (12), Cause (13), EPC (14), PRId (15)
SR: 判断某种异常是否被允许发生 EXL(SR[1]) 总开关 1'b0表示允许 IE(SR[0]) 外部中断开关 1'b1表示允许 IM(SR[15:10]) 各种中断允许位 1'b1表示允许  
Cause: 存储陷入内核原因 BD(Cause[31]) 1'b1表示在延迟槽中发生 IP(Cause[15:10]) 各种中断请求位 1'b1表示请求 ExcCode(Cause[6:2]) 异常代码  
EPC: 异常发生时的返回地址  
PRId: 处理器标识
```
判断是否发生异常：
```verilog
assign Req = ((`SR_IE && (`SR_IM & HWInt)) || ExcCode) && (~`SR_EXL);
```
输入输出信号：
```
ExcCode：异常代码，在各级判断汇总后传入  
VPC：陷入内核的PC地址  
HWInt：外部中断信号  
BD：是否是延迟槽中的指令  
EXLclr：根据eret指令信号进行恢复现场  
Req：判断是否发生异常  
EPCOut：输出返回现场的PC值  
WE：mtc0写使能  
WD：mtc0写入数据  
addr：根据指令中Rd的值判断写入的寄存器  
data：mfc0读出数据
```
将CP0模块放在M级，可解决在M级可能出现的新异常，对于乘除法操作在检测到异常信号时已经将本周期的内容写入寄存器的问题，解决方案为在MDU模块内部设置两个寄存器储存上一周期的内容，一旦检测到中断信号将HI、LO寄存器赋值为上一周期寄存器，实现撤回写入的功能。  
### 宏观PC
用于将流水线CPU封装成单周期CPU。为保证中断异常发生时，宏观PC的顺序与实际顺序相同，宏观PC的监测点设置于CP0同级的M级。
### 异常检测
F级：PC地址未对齐/越界  
D级：指令的合法性/syscall指令  
E级：算术溢出  
M级：内存地址未对齐/越界  
逐级流水并按优先级整合后，得到最终的ExcCode传入CP0  
### 陷入内核
nPC需跳转到0x4180，清空流水线寄存器（PC变成0x4180），并阻止MDU写入，一切均由Req信号驱动。原因见上下文。
### 返回现场
在D级检测到eret指令后，直接将F级PC设置为EPC，跳过延迟槽。
### 外部中断
外部中断由顶层模块输入传入，并直接传入CP0。  
为防止外部中断时，刚好是空泡指令流水，需在流水线寄存器复位时，选择性地复位PC信号。具体如下：
```verilog
if (reser | Req | clear) begin
D_PC <= reset ? 32'b0 : Req ? 32'h00004180 : F_PC;
E_PC <= reset ? 32'b0 : Req ? 32'h00004180 : D_PC;
M_PC <= reset ? 32'b0 : Req ? 32'h00004180 : E_PC;
W_PC <= reset ? 32'b0 : Req ? 32'h00004180 : M_PC;
end
```
BD信号同理。
### 外部信号模拟
将现有模块改为cpu.v，在顶层模块mips.v中，添加cpu，timer0，timer1，bridge四个模块。其中，bridge系统桥负责系统各个模块、以及各个模块与外部输入输出之间的通信。
## 流水线结构
### Fetch Zone
包含`IFU` `F/D`模块，`IFU`中`nPC`的计算方式如下：
```
if D级为非跳转指令/相对跳转指令但不满足跳转条件 then 
    nPC = F_PC+4
if D级是相对跳转指令且满足跳转条件 then
    nPC = D_PC + 4 + sign_entend(imm16 << 2)
    //即F_PC + sign_entend(offset << 2) (延迟槽，无论是否是跳转指令，下一条指令一定是PC+4，即无论D级指令是什么，当前的F_PC一定是D_PC+4)
if D级是绝对跳转指令
    nPC = F_PC[31:28] || (imm26 << 2)
    //同样地，在绝对跳转指令中，跳转地址的最高四位来自延迟槽中的指令，若跳转指令为0xfffffffc，则延迟槽中的指令前四位一定为0001，即跳转地址只能在跳转指令之后
if D级是jr/jalr
    nPC = GRF
```
需要在F/D中流水的数据为`Instr` `PC` `PCplus8`
### Decode Zone
包含`Controller` `GRF` `ImmExt ``zero` `D/E`模块，其中`GRF`在D级负责读取寄存器数据并进行流水，而写相关信号来自W级，`zero`模块负责向F级提供计算`nPC`所需变量  
流水数据为`Instr` `PC` `PCplus8` `fixedRD1` `fixedRD2` `A3` `Imm32`,注意所有使用RD1/2的模块(zero，D/E)均需使用由转发得到的的fixedRD1/2$
### Execute Zone
包含`Controller` `ALU` `DMU` `E/M`模块，其中`ALU`输入数据`ALUIn1/2`由控制信号`ALUInput1/2`决定，使用的RD1/2均为转发得到的fixedRD1/2  
流水数据为`Instr` `PC` `PCplus8` `ALUOut` `RD2` `A3`，同样地，RD2为转发得到的fixedRD2
### Memory Zone
包含`Controller` `DMLoad` `DMSave` `M/W`模块，其中`DM`输入地址来自流水的ALUOut，输入数据来自转发得到的fixedRD2  
流水数据为`Instr` `PC` `PCplus8` `A3` `ALUOut` `DMData`
### WriteBack Zone
包含`Controller` `choooseRegWE`模块，其中chooseRegWE根据Controller输出信号与指令共同决定是否写入GRF，根据题目要求可增设选项（可能增加流水的数据），写回GRF的数据根据控制信号选择`PCplus8` `DMData`(代码中为`W_data`)或`ALUOut`
## 阻塞与转发
### 转发
#### 触发条件
令：级次为：`D-0 E-1 M-2 W-3`一条指令需要用到rs/rt寄存器的级次为`t_rs/t_rt`，产生写入寄存器值的级次为`t`,前一条指令到D的距离为`t1`，后一条指令到D的距离为`t2`，记`t_rs_use = t_rs - t2   t_rt_use = t_rt - t2 t_new = t - t1`，则转发的触发条件为：
$$t_{rsuse} >= t_{new}$$
$$t_{rtuse} >= t_{new}$$
另外，若t_use/t_new<0，则记为0
#### 数据通路
为保证不会出现在一个周期中间发生转发，转发终点处数据来不及计算完毕便到了下一个周期，而使得数据赶不上流水，故保证转发的起点需在每一个级次的起点  
起点：M级ALUOut（E级的计算结果） W级RegWriteData E/M的PCplus8（W级与RegWriteData汇合，D级因F级不需要，无需转发）
终点：zero模块的两个输入 ALU模块的两个输入 DM模块的数据输入
除去起点终点在同一级的情况，共有15种数据通路
### 判断条件
1. 是否为 isPCplus8
2. 寄存器编号是否为 0
 . 转发起点和终点寄存器是否相同
4. t_use 值是否存在
5. t_new 值是否存在
6. t_use 是否大于等于 t_new
### 阻塞
#### 触发条件
不满足转发条件时，需要进行阻塞  
可以证明，若不满足触发条件，指令在任意一级均不满足触发条件，故只需使后一指令在D级时对E/M/W的指令进行判断即可，任一不满足均需进行阻塞
#### 实现细节
下一时钟上升沿严禁写入PC，关闭F/D写使能保证D级数据不变，清空D/E数据即为E级加入nop，M/W正常流水
#### 判断条
1. 寄存器编号是否为 0
2. 转发起点和终点寄存器是否相同
3. t_use 值是否存在
4. t_new 值是否存在
5. t_use 是否小于 t_new
## Controller
该模块加入了mfc0、mtc0、eret、syscall指令的识别和相应控制信号的适配，并提供了异常指令的ExcCode输出
***输出信号含义***：**type**:指令编码，传入ALU进行运算  
                  **nextPC_Sel**:IFU选择信号   
                  `next_Sel 0为PC+4 1为寄存器存储地址(绝对跳转) 2为imm26(相对跳转) 3为imm16+PC+4/PC+4(条件跳转)`   
                  **RegWE**:GRF的写使能信号  
                  **ALUInput1**：选择ALU第一个输入信号   
                  `ALUInput1 0为rs寄存器值，1为shamt`  
                  **ALUInput2**:选择ALU第二个输入信号   
                  `ALUInput2 0为rt寄存器值，1为32位立即数`  
                  **ExtOp**:将指令中的16为立即数拓展为32位立即数的拓展方式   
                  `ExtOp 0为0拓展，1为符号拓展`  
                  **RegDst**:选择写入的寄存器   
                  `RegDst 0为rd寄存器，1为rt寄存器`  
                  **DMWE**:DM的写使能信号  
                  **MemToReg**:选择写入GRF的值   
                  `MemToReg 0为ALU运算结果，1为DM存储的值`  
                  **PCToReg**:选择写入GRF的值   
                  `PCToReg 0为ALU运算结果或DM存储的值，1为PC+4的值（用于jal/jalr）`  
                  **RegRa**:选择写入的寄存器   
                  `RegRa 0为rd寄存器或rt寄存器，1为$ra寄存器`
                  **isMFHILO**:判断是否是mfhi/mflo指令
                  `isMFHILO 0为其他指令 1为mfhi/mflo指令`
                  **start**:乘除运算开始
                  `start 0为其他指令 1为乘除指令`  
                  **cpzWrite**:mtc0信号  
                  `cpzWrite 0为其他指令 1为mtc0指令`
                  **cpzFix**:mfc0信号  
                  `cpzFix 0为其他指令 1为mfc0指令`
                  **ExcCode**:指令相关异常
                  `ExcCode 5'd8为系统调用 5'd10为未知指令`
# 测试方案
未开发评测机，将机器码转化为mips后逐个比对
# 思考题
1. 外设产生相应信号后，通过中断请求线向中断控制器发送信号，由中断控制器选择产生中断信号，发送给CPU，CPU检测到中断信号后陷入内核，处理外设信息后返回现场
2. 指定好的地址，可以保证在操作系统未加载完成时同样能够响应错误中断，且能够保护内核态，防止用户随意更改；若支持用户自定义，可能会有恶意代码注入内核，或跳转时该自定义进程已被回收等情况，造成系统崩溃。
3. Bridge可以起到地址映射、时钟同步、信号片选等作用。
4. mode0计时结束后停止，mode1计时结束后重新开始计时。状态转移：
MODE0:
(开启: ctrl[0]=1)
           +-----------------------+
           |      _IRQ=0           v
    +------+------+         +------+------+
    |    IDLE     |         |    LOAD     |
    |             |         |             |
    +------+------+         +------+------+
           ^                       |
           |                       | (count=preset)
           |                       v
    +------+------+         +------+-------+
    |     INT     |         |    CNT       | <---+
    |             | <-----  |              |     | (count > 1)
    +-------------+ _IRQ=1  +-------------+ ----+
       (硬件自动              (count == 1)
        清零ctrl)
MODE1:
(开启: ctrl[0]=1)
           +-----------------------+
           |                       v
    +------+------+         +------+------+
    |    IDLE     |         |    LOAD     | <-----------+
    |             |         |             |             |
    +-------------+         +------+------+             |
                                   |                    |
                                   | (无条件)            |
                                   v                    | (自动重装载)
                            +------+------+             |
                      +---- |     CNT     |             |
          (count > 1) |     |             |             |
                      +---> +------+------+             |
                                   |                    |
                                   | (count == 1)       |
                                   v                    |
                            +------+------+             |
                            |     INT     | ____________|
                            |             |
                            +-------------+
5. 失去返回现场的地址。故应保留PC、BD等信息。
6. 同时使用和写入$31，是未定义行为，可能造成不可预知的后果。